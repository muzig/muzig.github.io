{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"About Me","date":"2020-12-30T10:26:32.396Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"期待最好的你.","text":"期待最好的你. 自我介绍"},{"title":"categories","date":"2020-12-29T09:41:25.000Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-29T09:44:24.000Z","updated":"2020-12-30T10:26:32.400Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang 初级面试","slug":"golang-primary-interview","date":"2020-12-27T20:18:15.000Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"2020/12/27/golang-primary-interview/","link":"","permalink":"http://example.com/2020/12/27/golang-primary-interview/","excerpt":"最近需要答辩, 收集了部分来自各方的实战面试内容, 便于巩固. 如有不当之处，请予指正 🙏.","text":"最近需要答辩, 收集了部分来自各方的实战面试内容, 便于巩固. 如有不当之处，请予指正 🙏. TODO 参考链接 基础篇 概念篇 框架篇 开源框架 数据库篇 线上经验 编程题 实现字符串匹配检查 实现一种或多种负载均衡算法 TODO 尽可能完善题目答案 参考链接 ShowMeBug-初级 Golang 面试视频 基础篇 new 和 make 的区别? 都是用于分配内存, 区别在于: 前者主要用于创建返回类型的指针引用; 后者只能用于 slice / map / channel 的初始化. 补充: 其实 new 不常用, 相比较下字面量初始化的方式更为常用, 同时获取指针引用之后, 对于对象的赋值, 还会导致间接赋值的逃逸问题 函数调用传引用类型还是值类型? (涉及逃逸问题) 一般采用引用类型, 少数采用值类型, 这里主要参考的是: 函数内需要或者不需要修改引用类型的值; 其他情况考虑逃逸的问题, 若函数是变量, 则函数参数是引用的话, 会导致函数变量逃逸. 反射的原理? (如何解析 struct 的 tag) recover 能捕获子 goroutine 的 panic 吗? 锁相关的使用情况? 自己使用 channel 的使用场景以及坑? 概念篇 内存管理 线程协程的占用内存大小? 进程模型 进程状态转换 线程模型 线程如果发生 OOM 如何排查处理? 同理 goroutine 发生 OOM ? 调度逻辑 什么时候 goroutine 阻塞? 调度器如何处理? goroutine 一直占用资源如何处理? 框架篇 项目中如何错误处理? 会自定义 error 错误处理吗? gRPC 使用情况? 服务发现/负债均衡的实现? proto 文件如何管理? (monorepo 尝试) 如果中心节点挂掉如何处理? (Raft算法保证可靠性) 开源框架Web: gin beego Gin 中的自定义参数校验规则? Gin 中间件的使用情况 Game: leaf origin leaf 的消息路由方式? 数据库篇 mongodb mysql redis redis mongodb mysql 的锁机制? redis 的基本内容, 使用情况? redis 持久性如何处理? mysql ORM使用情况? (XORM / GORM) mysql 分库分表情况? (分片存储, HBase存储) 主从模式/集群模式/哨兵模式区别? 线上经验 线上 bug 如何排查? 如何分析线上性能瓶颈? 编程题实现字符串匹配检查正确输出以下结果: 即需要同时成对的符号, 即判断成功 123&quot;[()]&quot; =&gt; true&quot;[(]&quot; =&gt; false&quot;&#123;]]&quot; =&gt; false 实现一种或多种负载均衡算法","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"interview","slug":"interview","permalink":"http://example.com/tags/interview/"}]},{"title":"Golang Escape Analysis","slug":"golang-escape-analysis","date":"2020-12-27T14:42:27.000Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"2020/12/27/golang-escape-analysis/","link":"","permalink":"http://example.com/2020/12/27/golang-escape-analysis/","excerpt":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码.","text":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码. 关于堆栈 逃逸分析 函数变量 间接赋值 interface channel 可变参数 总结 参考链接 Go 语言较之 C 语言一个很大的优势就是自带 GC 功能，可 GC 并不是没有代价的。写 C 语言的时候，在一个函数内声明的变量，在函数退出后会自动释放掉，因为这些变量分配在栈上。如果你想要变量的数据能在函数退出后还能访问，就需要调用 malloc 方法在堆上申请内存，如果程序不再需要这块内存了，再调用 free 方法释放掉。Go 语言不需要你主动调用 malloc 来分配堆空间，编译器会自动分析，找出需要 malloc 的变量，使用堆内存。编译器的这个分析过程就叫做逃逸分析。 关于堆栈区别如下: 申请方式的不同。栈由系统自动分配，而堆是人为申请开辟; 申请大小的不同。栈获得的空间较小，而堆获得的空间较大; 申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢; 存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排; 底层不同。栈是连续的空间，而堆是不连续的空间。 详细细节链接: Language Mechanics On Stacks And Pointers Language Mechanics On Escape Analysis 12345678910func stack() int &#123; // 变量 i 会在栈上分配 i := 10 return i&#125;func heap() *int &#123; // 变量 j 会在堆上分配 j := 10 return &amp;j&#125; 123# 分析汇编指令如下:go build --gcflags &#x27;-l&#x27; test.gogo tool objdump ./test !!! 不要以为使用了堆内存就一定会导致性能低下，使用栈内存会带来性能优势。因为实际项目中，系统的性能瓶颈一般都不会出现在内存分配上。千万不要盲目优化，找到系统瓶颈，用数据驱动优化。 逃逸分析需要使用堆空间则逃逸，这没什么可争议的。但编译器有时会将不需要使用堆空间的变量，也逃逸掉。这里是容易出现性能问题的大坑。网上有很多相关文章，列举了一些导致逃逸情况，其实总结起来就一句话： 多级间接赋值容易导致逃逸。 Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type(指针)。 记住公式 Data.Field = Value，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递。 函数变量 若函数是变量, 且参数也是引用类型, 则会发生逃逸 间接赋值 良好的写法是, 在返回的时候再引用地址 1234567891011121314151617181920212223type Data struct &#123; data map[int]int slice []int ch chan int inf interface&#123;&#125; p *int&#125;func main() &#123; d1 := Data&#123;&#125; d1.data = make(map[int]int) // GOOD: does not escape d1.slice = make([]int, 4) // GOOD: does not escape d1.ch = make(chan int, 4) // GOOD: does not escape d1.inf = 3 // GOOD: does not escape d1.p = new(int) // GOOD: does not escape d2 := new(Data) // d2 是指针变量， 下面为该指针变量中的指针成员赋值 d2.data = make(map[int]int) // BAD: escape to heap d2.slice = make([]int, 4) // BAD: escape to heap d2.ch = make(chan int, 4) // BAD: escape to heap d2.inf = 3 // BAD: escape to heap d2.p = new(int) // BAD: escape to heap&#125; interface只要使用了 Interface 类型(不是 interafce{})，那么赋值给它的变量一定会逃逸。因为 interfaceVariable.Method() 先是间接的定位到它的实际值，再调用实际值的同名方法，执行时实际值作为参数传递给方法。相当于interfaceVariable.Method.this = realValue 123456789101112131415type Iface interface &#123; Dummy()&#125;type Integer intfunc (i Integer) Dummy() &#123;&#125;func main() &#123; var ( iface Iface i Integer ) iface = i iface.Dummy() // make i escape to heap // 形成 iface.Dummy.i = i&#125; channel 发送到 channel 的数据类型都将逃逸 12345678910111213func test() &#123; var ( chInteger = make(chan *int) chMap = make(chan map[int]int) chSlice = make(chan []int) chInterface = make(chan interface&#123;&#125;) a, b, c, d = 0, map[int]int&#123;&#125;, []int&#123;&#125;, 32 ) chInteger &lt;- &amp;a // 逃逸 chMap &lt;- b // 逃逸 chSlice &lt;- c // 逃逸 chInterface &lt;- d // 逃逸&#125; 可变参数可变参数如 func(arg …string) 实际与 func(arg []string) 是一样的，会增加一层访问路径。这也是 fmt.Sprintf 总是会使参数逃逸的原因。 例子非常多，这里不能一一列举，我们只需要记住分析方法就好 即，2 级或更多级的访问赋值会容易导致数据逃逸。这里加上容易二字是因为随着语言的发展，相信这些问题会被慢慢解决，但现阶段，这个可以作为我们分析逃逸现象的依据。 123456789101112type User struct &#123; roles []string&#125;func (u *User) SetRoles(roles []string) &#123; u.roles = roles&#125;func SetRoles(u User, roles []string) User &#123; u.roles = roles return u&#125; 12345678910111213141516171819202122232425type User struct &#123; A []string&#125;func (u *User) Set(a []string) &#123; u.A = a&#125;func SetUser(user User, a []string) User &#123; user.A = a return user&#125;func BenchmarkUser(b *testing.B) &#123; // BenchmarkUser-4 39182143 29.0 ns/op //u := new(User) //for i := 0; i &lt; b.N; i++ &#123; // u.Set([]string&#123;&quot;a&quot;&#125;) //&#125; // BenchmarkUser-4 1000000000 0.585 ns/op for i := 0; i &lt; b.N; i++ &#123; _ = SetUser(User&#123;&#125;, []string&#123;&quot;a&quot;&#125;) &#125;&#125; 总结 大多数情况下，性能优化都会为程序带来一定的复杂度。建议实际项目中还是怎么方便怎么写，功能完成后通过性能分析找到瓶颈所在，再对局部进行优化。 多级间接赋值会导致 Go 编译器出现不必要的逃逸，在一些情况下可能我们只需要修改一下数据结构就会使性能有大幅提升。这也是很多人不推荐在 Go 中使用指针的原因，因为它会增加一级访问路径，而 map, slice, interface{}等类型是不可避免要用到的，为了减少不必要的逃逸，只能拿指针开刀了。 参考链接 达菲格-Go 语言内存管理（三）：逃逸分析","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"escape-analysis","slug":"escape-analysis","permalink":"http://example.com/tags/escape-analysis/"}]},{"title":"Golang GC","slug":"golang-GC","date":"2020-12-26T23:32:41.000Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"2020/12/26/golang-GC/","link":"","permalink":"http://example.com/2020/12/26/golang-GC/","excerpt":"标记清除 并行标记清除 三色标记法 Hybrid Write Barrier","text":"标记清除 并行标记清除 三色标记法 Hybrid Write Barrier 标记清除 &amp; 并行标记清除 三色标记法 Hybrid Write Barrier (混合写屏障) 何时触发 GC 其他优化 展望 结论 参考链接 标记清除 &amp; 并行标记清除GC 开始之后, 启动 STW 然后从 root 开始, root 区值当前所有 goroutine 的栈和全局数据区的变量(主要是这 2 个地方), 将能被触及的 object 标记, 剩下的就是可回收的; 最后再清理放回 mcache 中, 以备后续使用. 并行标记清除, 实际上是清理过程不需要 STW, 减少了 STW 的时间. 三色标记法 正常情况下，写操作就是正常的赋值。 GC 开始，开启写屏障等准备工作。开启写屏障等准备工作需要短暂的 STW。 Stack scan 阶段，从全局空间和 goroutine 栈空间上收集变量。 Mark 阶段，执行上述的三色标记法，直到没有灰色对象。 Mark termination 阶段，开启 STW，回头重新扫描 root 区域新变量，对他们进行标记。 Sweep 阶段，关闭 STW 和 写屏障，对白色对象进行清除。 Hybrid Write Barrier (混合写屏障)Go 在 1.8 版本引入了混合写屏障，其会在赋值前，对旧数据置灰，再视情况对新值进行置灰。 何时触发 GC 容量触发 - 达到设置的阈值触发 GC, 默认为100(即内存增长100%即触发一次), 可以通过环境变量 GOGC 或者 debug.SetGCPercent() 时间触发 - 每隔 2 分钟, 触发一次 GC 手动触发 - runtime.GC() 其他优化 只会占用 25% 的 cpu 算力处理 GC 逻辑, 保证减少对用户的影响. 若下一轮 GC 触发, 会等待上一轮执行完毕 对于 tiny 对象, 直接标记黑色, 没有灰色阶段, 因为不存在引用对象 采用对象池的方式, 减少 GC 的压力, 但实际上也会存在标记的压力; 如果可以放在永久标记, 就可以减少标记压力 直接申请大内存(大于32k), 对 GC 来说是一个 largespan; 需要自行代码管理 展望 引入分代机制, 像 JVM 那样内存分为 一级/二级/永久, 不同级别, 采用不同的计算资源 结论 减少层级数 - 嵌套层级越多, 对于 GC 的压力越大; 如: chan map[string][]*string 参考链接 吴戴均-Golang GC核心要点和度量方法 吴戴均-常见GC算法及Golang GC 达菲格-Go 语言内存管理（四）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"gc","slug":"gc","permalink":"http://example.com/tags/gc/"}]},{"title":"Golang Scheduling","slug":"golang-scheduling","date":"2020-12-26T15:40:47.000Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"2020/12/26/golang-scheduling/","link":"","permalink":"http://example.com/2020/12/26/golang-scheduling/","excerpt":"熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.","text":"熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑. GPM 模型 参考链接 GPM 模型 G(Goroutine) P(Process) M(Machine) 参考链接 吴戴均-Go 调度模型 吴戴均-再谈调度 达菲格-Go 语言调度（一）: 系统调度 达菲格-Go 语言调度（二）: goroutine 调度器 达菲格-Go 语言调度（三）: 并发","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"scheduling","slug":"scheduling","permalink":"http://example.com/tags/scheduling/"}]},{"title":"Shell 笔记","slug":"shell-note","date":"2020-12-19T15:22:53.000Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"2020/12/19/shell-note/","link":"","permalink":"http://example.com/2020/12/19/shell-note/","excerpt":"在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务. 科技改变生活, 脚本释放双手.","text":"在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务. 科技改变生活, 脚本释放双手. 基础语法 变量 字符串 数组 注释 传参 运算符 算数运算符 逻辑运算符 布尔运算符 关系运算符 字符串运算符 文件测试运算符 流程控制 条件控制 循环控制 函数 重定向 /dev/null 文件 文件引用 oh-my-zsh 源码 参考链接 基础语法变量123# 赋值等号两边不能添加空格name=&#x27;hello&#x27;echo $&#123;name&#125; 123# 常量name=&#x27;hello&#x27;readonly name 123# 删除变量name=&#x27;hello&#x27;unset name 字符串 单引号 原样输出, 不支持变量引用 双引号 支持变量引用 支持转义字符 123# 获取字符串长度name=&#x27;hello&#x27;echo $&#123;#name&#125; 123# 提取字符串name=&#x27;hello world&#x27;echo $&#123;name:1:3&#125; # 输出ell 123# 查找字符串string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 数组123array_name=(value1 value2 ... valuen)# 访问v1=$&#123;array_name[0]&#125; 注释1234567# 单行注释:&lt;&lt;EOF多行注释多行注释EOF符号可以换成其他, 比如`&#x27;之类的EOF 传参 $0: 文件名 $1: 命令行执行的第一个参数 $2: 命令行执行的第二个参数 运算符算数运算符 逻辑运算符 布尔运算符 关系运算符 字符串运算符 文件测试运算符 流程控制关键字: break continue 条件控制12345678910111213# 多行if condition1then command1elif condition2 then command2else commandNfi# 单行if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 循环控制1234567891011# 多行for var in item1 item2 ... itemNdo command1 command2 ... commandNdone# 单行for var in item1 item2 ... itemN; do command1; command2… done; 1234567891011121314151617# 条件循环while conditiondo commanddone# 条件循环until conditiondo commanddone# 无限循环while :do commanddone 函数12345678910# 语法[ function ] funname [()]&#123; action; [return int;]&#125; 123456demoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 1234输出结果:-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 重定向 /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1command &gt; /dev/null 文件引用1url=&quot;http://muzig.github.io&quot; 1234567# 使用 . 号来引用src.sh 文件. ./src.sh# 或者使用以下包含文件代码source ./src.shecho &quot;Blog：$url&quot; 12输出:Blog: http://muzig.github.io oh-my-zsh 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# If ZSH is not defined, use the current script&#x27;s directory.[[ -z &quot;$ZSH&quot; ]] &amp;&amp; export ZSH=&quot;$&#123;$&#123;(%):-%x&#125;:a:h&#125;&quot;# Set ZSH_CACHE_DIR to the path where cache files should be created# or else we will use the default cache/if [[ -z &quot;$ZSH_CACHE_DIR&quot; ]]; then ZSH_CACHE_DIR=&quot;$ZSH/cache&quot;fi# Check for updates on initial load...if [ &quot;$DISABLE_AUTO_UPDATE&quot; != &quot;true&quot; ]; then source $ZSH/tools/check_for_upgrade.shfi# Initializes Oh My Zsh# add a function pathfpath=($ZSH/functions $ZSH/completions $fpath)# Load all stock functions (from $fpath files) called below.autoload -U compaudit compinit# Set ZSH_CUSTOM to the path where your custom config files# and plugins exists, or else we will use the default custom/if [[ -z &quot;$ZSH_CUSTOM&quot; ]]; then ZSH_CUSTOM=&quot;$ZSH/custom&quot;fiis_plugin() &#123; local base_dir=$1 local name=$2 builtin test -f $base_dir/plugins/$name/$name.plugin.zsh \\ || builtin test -f $base_dir/plugins/$name/_$name&#125;# Add all defined plugins to fpath. This must be done# before running compinit.for plugin ($plugins); do if is_plugin $ZSH_CUSTOM $plugin; then fpath=($ZSH_CUSTOM/plugins/$plugin $fpath) elif is_plugin $ZSH $plugin; then fpath=($ZSH/plugins/$plugin $fpath) else echo &quot;[oh-my-zsh] plugin &#x27;$plugin&#x27; not found&quot; fidone# Figure out the SHORT hostnameif [[ &quot;$OSTYPE&quot; = darwin* ]]; then # macOS&#x27;s $HOST changes with dhcp, etc. Use ComputerName if possible. SHORT_HOST=$(scutil --get ComputerName 2&gt;/dev/null) || SHORT_HOST=$&#123;HOST/.*/&#125;else SHORT_HOST=$&#123;HOST/.*/&#125;fi# Save the location of the current completion dump file.if [ -z &quot;$ZSH_COMPDUMP&quot; ]; then ZSH_COMPDUMP=&quot;$&#123;ZDOTDIR:-$&#123;HOME&#125;&#125;/.zcompdump-$&#123;SHORT_HOST&#125;-$&#123;ZSH_VERSION&#125;&quot;fi# Construct zcompdump OMZ metadatazcompdump_revision=&quot;#omz revision: $(builtin cd -q &quot;$ZSH&quot;; git rev-parse HEAD 2&gt;/dev/null)&quot;zcompdump_fpath=&quot;#omz fpath: $fpath&quot;# Delete the zcompdump file if OMZ zcompdump metadata changedif ! command grep -q -Fx &quot;$zcompdump_revision&quot; &quot;$ZSH_COMPDUMP&quot; 2&gt;/dev/null \\ || ! command grep -q -Fx &quot;$zcompdump_fpath&quot; &quot;$ZSH_COMPDUMP&quot; 2&gt;/dev/null; then command rm -f &quot;$ZSH_COMPDUMP&quot; zcompdump_refresh=1fiif [[ $ZSH_DISABLE_COMPFIX != true ]]; then source $ZSH/lib/compfix.zsh # If completion insecurities exist, warn the user handle_completion_insecurities # Load only from secure directories compinit -i -C -d &quot;$&#123;ZSH_COMPDUMP&#125;&quot;else # If the user wants it, load from all found directories compinit -u -C -d &quot;$&#123;ZSH_COMPDUMP&#125;&quot;fi# Append zcompdump metadata if missingif (( $zcompdump_refresh )); then # Use `tee` in case the $ZSH_COMPDUMP filename is invalid, to silence the error # See https://github.com/ohmyzsh/ohmyzsh/commit/dd1a7269#commitcomment-39003489 tee -a &quot;$ZSH_COMPDUMP&quot; &amp;&gt;/dev/null &lt;&lt;EOF$zcompdump_revision$zcompdump_fpathEOFfiunset zcompdump_revision zcompdump_fpath zcompdump_refresh# Load all of the config files in ~/oh-my-zsh that end in .zsh# TIP: Add files you don&#x27;t want in git to .gitignorefor config_file ($ZSH/lib/*.zsh); do custom_config_file=&quot;$&#123;ZSH_CUSTOM&#125;/lib/$&#123;config_file:t&#125;&quot; [ -f &quot;$&#123;custom_config_file&#125;&quot; ] &amp;&amp; config_file=$&#123;custom_config_file&#125; source $config_filedone# Load all of the plugins that were defined in ~/.zshrcfor plugin ($plugins); do if [ -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh elif [ -f $ZSH/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH/plugins/$plugin/$plugin.plugin.zsh fidone# Load all of your custom configurations from custom/for config_file ($ZSH_CUSTOM/*.zsh(N)); do source $config_filedoneunset config_file# Load the themeif [ ! &quot;$ZSH_THEME&quot; = &quot;&quot; ]; then if [ -f &quot;$ZSH_CUSTOM/$ZSH_THEME.zsh-theme&quot; ]; then source &quot;$ZSH_CUSTOM/$ZSH_THEME.zsh-theme&quot; elif [ -f &quot;$ZSH_CUSTOM/themes/$ZSH_THEME.zsh-theme&quot; ]; then source &quot;$ZSH_CUSTOM/themes/$ZSH_THEME.zsh-theme&quot; else source &quot;$ZSH/themes/$ZSH_THEME.zsh-theme&quot; fifi 参考链接 阮一峰的《Bash 脚本教程》 Shell 教程 | 菜鸟教程","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"Goland 破解教程","slug":"goland-cracking","date":"2020-12-05T12:58:28.000Z","updated":"2020-12-30T10:26:32.396Z","comments":true,"path":"2020/12/05/goland-cracking/","link":"","permalink":"http://example.com/2020/12/05/goland-cracking/","excerpt":"破解方式: 循环重置试用时间.","text":"破解方式: 循环重置试用时间. 教程 友情链接 教程步骤: 打开 goland, 选择试用, 进入IDE界面 Menu - Goland - Perference - Plugins 点击像齿轮的图标(如下图) Manager Plugin Repos 添加此链接: https://plugins.zhile.io, 等待刷新完成 搜索插件 IDE Eval reset, 插件描述有说明和使用方法 下载安装重启 IDE 友情链接 破解大佬博客","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"crack","slug":"crack","permalink":"http://example.com/tags/crack/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"interview","slug":"interview","permalink":"http://example.com/tags/interview/"},{"name":"escape-analysis","slug":"escape-analysis","permalink":"http://example.com/tags/escape-analysis/"},{"name":"gc","slug":"gc","permalink":"http://example.com/tags/gc/"},{"name":"scheduling","slug":"scheduling","permalink":"http://example.com/tags/scheduling/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"},{"name":"crack","slug":"crack","permalink":"http://example.com/tags/crack/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]}