{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"About Me","date":"2020-12-29T07:21:48.863Z","updated":"2020-12-29T07:21:48.863Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"期待最好的你.","text":"期待最好的你. 自我介绍"},{"title":"categories","date":"2020-12-29T09:41:25.000Z","updated":"2020-12-29T07:21:48.863Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-29T09:44:24.000Z","updated":"2020-12-29T07:21:48.863Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang Escape Analysis","slug":"golang-escape-analysis","date":"2020-12-29T14:42:27.000Z","updated":"2020-12-29T07:21:48.863Z","comments":true,"path":"2020/12/29/golang-escape-analysis/","link":"","permalink":"http://example.com/2020/12/29/golang-escape-analysis/","excerpt":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码.","text":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码. Go 语言较之 C 语言一个很大的优势就是自带 GC 功能，可 GC 并不是没有代价的。写 C 语言的时候，在一个函数内声明的变量，在函数退出后会自动释放掉，因为这些变量分配在栈上。如果你想要变量的数据能在函数退出后还能访问，就需要调用 malloc 方法在堆上申请内存，如果程序不再需要这块内存了，再调用 free 方法释放掉。Go 语言不需要你主动调用 malloc 来分配堆空间，编译器会自动分析，找出需要 malloc 的变量，使用堆内存。编译器的这个分析过程就叫做逃逸分析。 关于堆栈区别如下: 申请方式的不同。栈由系统自动分配，而堆是人为申请开辟; 申请大小的不同。栈获得的空间较小，而堆获得的空间较大; 申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢; 存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排; 底层不同。栈是连续的空间，而堆是不连续的空间。 详细细节链接: Language Mechanics On Stacks And Pointers Language Mechanics On Escape Analysis 12345678910func stack() int &#123; // 变量 i 会在栈上分配 i := 10 return i&#125;func heap() *int &#123; // 变量 j 会在堆上分配 j := 10 return &amp;j&#125; 123# 分析汇编指令如下:go build --gcflags &#x27;-l&#x27; test.gogo tool objdump ./test !!! 不要以为使用了堆内存就一定会导致性能低下，使用栈内存会带来性能优势。因为实际项目中，系统的性能瓶颈一般都不会出现在内存分配上。千万不要盲目优化，找到系统瓶颈，用数据驱动优化。 逃逸分析需要使用堆空间则逃逸，这没什么可争议的。但编译器有时会将不需要使用堆空间的变量，也逃逸掉。这里是容易出现性能问题的大坑。网上有很多相关文章，列举了一些导致逃逸情况，其实总结起来就一句话： 多级间接赋值容易导致逃逸。 Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type(指针)。 记住公式 Data.Field = Value，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递。 函数变量 若函数是变量, 且参数也是引用类型, 则会发生逃逸 间接赋值 良好的写法是, 在返回的时候再引用地址 1234567891011121314151617181920212223type Data struct &#123; data map[int]int slice []int ch chan int inf interface&#123;&#125; p *int&#125;func main() &#123; d1 := Data&#123;&#125; d1.data = make(map[int]int) // GOOD: does not escape d1.slice = make([]int, 4) // GOOD: does not escape d1.ch = make(chan int, 4) // GOOD: does not escape d1.inf = 3 // GOOD: does not escape d1.p = new(int) // GOOD: does not escape d2 := new(Data) // d2 是指针变量， 下面为该指针变量中的指针成员赋值 d2.data = make(map[int]int) // BAD: escape to heap d2.slice = make([]int, 4) // BAD: escape to heap d2.ch = make(chan int, 4) // BAD: escape to heap d2.inf = 3 // BAD: escape to heap d2.p = new(int) // BAD: escape to heap&#125; interface只要使用了 Interface 类型(不是 interafce{})，那么赋值给它的变量一定会逃逸。因为 interfaceVariable.Method() 先是间接的定位到它的实际值，再调用实际值的同名方法，执行时实际值作为参数传递给方法。相当于interfaceVariable.Method.this = realValue 123456789101112131415type Iface interface &#123; Dummy()&#125;type Integer intfunc (i Integer) Dummy() &#123;&#125;func main() &#123; var ( iface Iface i Integer ) iface = i iface.Dummy() // make i escape to heap // 形成 iface.Dummy.i = i&#125; channel 发送到 channel 的数据类型都将逃逸 12345678910111213func test() &#123; var ( chInteger = make(chan *int) chMap = make(chan map[int]int) chSlice = make(chan []int) chInterface = make(chan interface&#123;&#125;) a, b, c, d = 0, map[int]int&#123;&#125;, []int&#123;&#125;, 32 ) chInteger &lt;- &amp;a // 逃逸 chMap &lt;- b // 逃逸 chSlice &lt;- c // 逃逸 chInterface &lt;- d // 逃逸&#125; 可变参数可变参数如 func(arg …string) 实际与 func(arg []string) 是一样的，会增加一层访问路径。这也是 fmt.Sprintf 总是会使参数逃逸的原因。 例子非常多，这里不能一一列举，我们只需要记住分析方法就好 即，2 级或更多级的访问赋值会容易导致数据逃逸。这里加上容易二字是因为随着语言的发展，相信这些问题会被慢慢解决，但现阶段，这个可以作为我们分析逃逸现象的依据。 123456789101112type User struct &#123; roles []string&#125;func (u *User) SetRoles(roles []string) &#123; u.roles = roles&#125;func SetRoles(u User, roles []string) User &#123; u.roles = roles return u&#125; 12345678910111213141516171819202122232425type User struct &#123; A []string&#125;func (u *User) Set(a []string) &#123; u.A = a&#125;func SetUser(user User, a []string) User &#123; user.A = a return user&#125;func BenchmarkUser(b *testing.B) &#123; // BenchmarkUser-4 39182143 29.0 ns/op //u := new(User) //for i := 0; i &lt; b.N; i++ &#123; // u.Set([]string&#123;&quot;a&quot;&#125;) //&#125; // BenchmarkUser-4 1000000000 0.585 ns/op for i := 0; i &lt; b.N; i++ &#123; _ = SetUser(User&#123;&#125;, []string&#123;&quot;a&quot;&#125;) &#125;&#125; 总结 大多数情况下，性能优化都会为程序带来一定的复杂度。建议实际项目中还是怎么方便怎么写，功能完成后通过性能分析找到瓶颈所在，再对局部进行优化。 多级间接赋值会导致 Go 编译器出现不必要的逃逸，在一些情况下可能我们只需要修改一下数据结构就会使性能有大幅提升。这也是很多人不推荐在 Go 中使用指针的原因，因为它会增加一级访问路径，而 map, slice, interface{}等类型是不可避免要用到的，为了减少不必要的逃逸，只能拿指针开刀了。 参考链接 达菲格-Go 语言内存管理（三）：逃逸分析","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"escape-analysis","slug":"escape-analysis","permalink":"http://example.com/tags/escape-analysis/"}]},{"title":"Golang GC","slug":"golang-GC","date":"2020-12-28T23:32:41.000Z","updated":"2020-12-29T07:21:48.863Z","comments":true,"path":"2020/12/28/golang-GC/","link":"","permalink":"http://example.com/2020/12/28/golang-GC/","excerpt":"标记清除 并行标记清除 三色标记法 Hybrid Write Barrier","text":"标记清除 并行标记清除 三色标记法 Hybrid Write Barrier 标记清除 &amp; 并行标记清除GC 开始之后, 启动 STW 然后从 root 开始, root 区值当前所有 goroutine 的栈和全局数据区的变量(主要是这 2 个地方), 将能被触及的 object 标记, 剩下的就是可回收的; 最后再清理放回 mcache 中, 以备后续使用. 并行标记清除, 实际上是清理过程不需要 STW, 减少了 STW 的时间. 三色标记法 正常情况下，写操作就是正常的赋值。 GC 开始，开启写屏障等准备工作。开启写屏障等准备工作需要短暂的 STW。 Stack scan 阶段，从全局空间和 goroutine 栈空间上收集变量。 Mark 阶段，执行上述的三色标记法，直到没有灰色对象。 Mark termination 阶段，开启 STW，回头重新扫描 root 区域新变量，对他们进行标记。 Sweep 阶段，关闭 STW 和 写屏障，对白色对象进行清除。 Hybrid Write Barrier (混合写屏障)Go 在 1.8 版本引入了混合写屏障，其会在赋值前，对旧数据置灰，再视情况对新值进行置灰。 何时触发 GC 容量触发 - 达到设置的阈值触发 GC, 默认为100(即内存增长100%即触发一次), 可以通过环境变量 GOGC 或者 debug.SetGCPercent() 时间触发 - 每隔 2 分钟, 触发一次 GC 手动触发 - runtime.GC() 其他优化 只会占用 25% 的 cpu 算力处理 GC 逻辑, 保证减少对用户的影响. 若下一轮 GC 触发, 会等待上一轮执行完毕 对于 tiny 对象, 直接标记黑色, 没有灰色阶段, 因为不存在引用对象 采用对象池的方式, 减少 GC 的压力, 但实际上也会存在标记的压力; 如果可以放在永久标记, 就可以减少标记压力 直接申请大内存(大于32k), 对 GC 来说是一个 largespan; 需要自行代码管理 展望 引入分代机制, 像 JVM 那样内存分为 一级/二级/永久, 不同级别, 采用不同的计算资源 结论 减少层级数 - 嵌套层级越多, 对于 GC 的压力越大; 如: chan map[string][]*string 参考链接 达菲格-Go 语言内存管理（四）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"gc","slug":"gc","permalink":"http://example.com/tags/gc/"}]},{"title":"Goland 破解教程","slug":"goland-cracking","date":"2020-12-05T12:58:28.000Z","updated":"2020-12-29T07:21:48.863Z","comments":true,"path":"2020/12/05/goland-cracking/","link":"","permalink":"http://example.com/2020/12/05/goland-cracking/","excerpt":"破解方式: 循环重置试用时间.","text":"破解方式: 循环重置试用时间. 教程步骤: 打开 goland, 选择试用, 进入IDE界面 Menu - Goland - Perference - Plugins 点击像齿轮的图标(如下图) Manager Plugin Repos 添加此链接: https://plugins.zhile.io, 等待刷新完成 搜索插件 IDE Eval reset, 插件描述有说明和使用方法 下载安装重启 IDE 友情链接 破解大佬博客","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"crack","slug":"crack","permalink":"http://example.com/tags/crack/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"},{"name":"escape-analysis","slug":"escape-analysis","permalink":"http://example.com/tags/escape-analysis/"},{"name":"gc","slug":"gc","permalink":"http://example.com/tags/gc/"},{"name":"crack","slug":"crack","permalink":"http://example.com/tags/crack/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]}