{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://muzig.github.io","root":"/"},"pages":[{"title":"About Me","date":"2021-04-11T13:48:00.208Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"about/index.html","permalink":"http://muzig.github.io/about/index.html","excerpt":"期待最好的你.","text":"期待最好的你. 自我介绍"},{"title":"categories","date":"2020-12-29T09:41:25.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"categories/index.html","permalink":"http://muzig.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-11T13:48:00.212Z","updated":"2021-04-11T13:48:00.212Z","comments":true,"path":"scripts/main.js","permalink":"http://muzig.github.io/scripts/main.js","excerpt":"","text":"var __assign = (this && this.__assign) || function () { __assign = Object.assign || function(t) { for (var s, i = 1, n = arguments.length; i < n; i++) { s = arguments[i]; for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]; } return t; }; return __assign.apply(this, arguments); }; var obj = { a: \"a\", b: \"b\" }; var obj2 = __assign(__assign({}, obj), { a: \"b\" }); console.log(obj2);"},{"title":"tags","date":"2020-12-29T09:44:24.000Z","updated":"2021-04-11T13:48:00.212Z","comments":true,"path":"tags/index.html","permalink":"http://muzig.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac 同步文件到 Linux","slug":"scp","date":"2021-03-21T18:48:48.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2021/03/21/scp/","link":"","permalink":"http://muzig.github.io/2021/03/21/scp/","excerpt":"scp – secure copy (remote file copy program)","text":"scp – secure copy (remote file copy program) 基本用法 Mac 上传文件到Linux 12# scp + 文件路径 + 用户名@服务器地址:目标路径scp tmp.md root@192.168.0.1:/root/ 2、Linux 下载文件到 Mac 12# scp 用户名@服务器地址:目标路径 下载路径scp root@192.168.0.1:/root/tmp.md ~/Desktop/ 参数说明 -r: Recursively copy entire directories. Note that scp follows symbolic links encountered in the tree traversal. -P(port): Specifies the port to connect to on the remote host.","categories":[{"name":"Mac","slug":"Mac","permalink":"http://muzig.github.io/categories/Mac/"}],"tags":[{"name":"scp","slug":"scp","permalink":"http://muzig.github.io/tags/scp/"}]},{"title":"Git 问题收集","slug":"git","date":"2021-02-17T11:06:42.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2021/02/17/git/","link":"","permalink":"http://muzig.github.io/2021/02/17/git/","excerpt":"收集一些不常见关于 git 的一些问题, 以及处理办法.","text":"收集一些不常见关于 git 的一些问题, 以及处理办法. push clone –depth push报错信息: 切换多个github账号的时候, 会有权限冲突. 12remote: Permission to &lt;user-a&gt;.git denied to &lt;user-b&gt;fatal: unable to access &#x27;https://github.com/ xxxxx.git/&#x27;: &gt; The requested URL returned error: 403 解决方案: 12git config credential.username &lt;user-a&gt;git push origin main clone–depth 报错信息: 1! [remote rejected] main -&gt; main (shallow update not allowed) 原因: 最初克隆仓库采用的 –depth 参数, 然后修改 remote 重新推送新仓库. 1234567# 浅克隆git clone --depth=1 &lt;仓库地址&gt;# 修改remotegit remote remove origingit remote add origin &lt;新仓库地址&gt;# 推送git push -u origin &lt;xxx&gt; # 这个步骤就会发生报错 解决办法: 简单粗暴: 1234567# 清理记录rm -rf .git# 重新构建仓库git initgit remote add origin &lt;新仓库地址&gt;git push -u origin &lt;xxx&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"http://muzig.github.io/tags/git/"}]},{"title":"My Mac","slug":"oh-my-mac","date":"2021-02-03T23:38:39.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2021/02/03/oh-my-mac/","link":"","permalink":"http://muzig.github.io/2021/02/03/oh-my-mac/","excerpt":"整理从0到1使用Mac系统, 提高生产力第一步, 学会良好的使用工具.","text":"整理从0到1使用Mac系统, 提高生产力第一步, 学会良好的使用工具. 今天由于电池问题, 换了一波电脑, big sur系统, 之前打算升级来着一直怕有兼容性问题, 不过今天实际体验了下, 目前没有遇到什么问题, 这里顺带写一些装电脑细节, 便于快速整理恢复系统细节. TODO Terminal Homebrew iTerm2 zsh 软件篇 必备 工具 程序开发 其他细节 iTerm2 Goland Tmux oh-my-zsh 友情链接 TODO Terminal 软件篇 其他细节 TerminalHomebrew1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; iTerm21brew install --cask iterm2 zsh 安装 1brew install zsh &amp;&amp; chsh -s usr/local/bin/zsh 插件 ohmyzsh 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 12345678910111213brew install autojumpbrew install fzfbrew install gitbrew install git-lfsbrew install tmuxbrew install vimbrew install wgetbrew install telnetbrew install rlwrap 软件篇必备123456brew install --cask google-chromebrew install --cask dingtalkbrew install --cask wechatbrew install --cask qqbrew install --cask sogouinputbrew install --cask neteasemusic 印象笔记 工具1234brew install --cask appcleanerbrew install --cask [dozer](https://github.com/Mortennn/Dozer)brew install --cask snipastebrew install --cask tencent-lemon 程序开发123456brew install --cask golandbrew install --cask dockerbrew install --cask postmanbrew install --cask robo-3tbrew install --cask visual-studio-codebrew install --cask unity-hub 其他细节iTerm2 Alt + b / f 无法使用问题 Goland ideaVim快捷键冲突, 或者不生效的修改. Tmuxoh-my-zsh autojump 1brew install autojump zsh-autosuggestion 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions zsh-syntax-highlighting 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 123456789101112131415161718192021222324252627282930313233# Which plugins would you like to load?# Standard plugins can be found in $ZSH/plugins/# Custom plugins may be added to $ZSH_CUSTOM/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=( git git-flow git-auto-fetch git-lfs git-prompt github vscode tmux timer golang fzf autojump zsh-syntax-highlighting zsh-autosuggestions)source $ZSH/oh-my-zsh.shsource ~/.gvm/scripts/gvm# User configuration# export golangexport PATH=$PATH:$HOME/go/go1.13/binexport PATH=$PATH:$HOME/go/bin 友情链接 左岸博客 - zsh插件推荐 FungLeo - mac 下使用 iTerm 终端工具无法使用 alt+b 和 alt+f 快捷键的解决方法","categories":[{"name":"Mac","slug":"Mac","permalink":"http://muzig.github.io/categories/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://muzig.github.io/tags/mac/"}]},{"title":"tmux 快速指北","slug":"tmux","date":"2021-01-30T09:52:48.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2021/01/30/tmux/","link":"","permalink":"http://muzig.github.io/2021/01/30/tmux/","excerpt":"如果您用过screen的话, 相比知道它的好处, 这里记录一款类似的工具tmux.","text":"如果您用过screen的话, 相比知道它的好处, 这里记录一款类似的工具tmux. TODO 🚀 快速搭建 常用快捷键 插件 oh-my-tmux tmux-resurrect 友情链接 TODO 常用快捷键 🚀 快速搭建 Install Tmux: 12345678# macbrew install tmux# linux - RedHatyum install tmux# linux - Debianapt install tmux Clone TPM: 1git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm Put this at the bottom of ~/.tmux.conf ($XDG_CONFIG_HOME/tmux/tmux.conf works too): 123456# 推荐配置git clone https://github.com/gpakosz/.tmux.git ~/.tmux/oh-my-tmux/cp ~/.tmux/oh-my-tmux/.tmux.conf ~/# 自定义配置wget https://github.com/muzig/oh-my-mac/blob/main/tmux/.tmux.conf ~/.tmux.conf.local Reload TMUX environment so TPM is sourced: 12# type this in terminal if tmux is already running$ tmux source ~/.tmux.conf 常用快捷键插件oh-my-tmux作用: 通用tmux配置搭配 123git clone https://github.com/gpakosz/.tmux.gitln -s -f .tmux/.tmux.confcp .tmux/.tmux.conf.local . tmux-resurrect作用: 保存tmux的layout, 便于重启电脑快速恢复. Add plugin to the list of TPM plugins in .tmux.conf: Hit prefix + I to fetch the plugin and source it. You should now be able to use the plugin. 1set -g @plugin &#x27;tmux-plugins/tmux-resurrect&#x27; 友情链接 TPM oh-my-tmux tmux-resurrect","categories":[{"name":"工具","slug":"工具","permalink":"http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"tmux","slug":"tmux","permalink":"http://muzig.github.io/tags/tmux/"}]},{"title":"vue.js 纪录片","slug":"the-documentary-of-vue","date":"2021-01-29T21:19:57.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2021/01/29/the-documentary-of-vue/","link":"","permalink":"http://muzig.github.io/2021/01/29/the-documentary-of-vue/","excerpt":"值得一看. Click Here","text":"值得一看. Click Here","categories":[{"name":"前端","slug":"前端","permalink":"http://muzig.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://muzig.github.io/tags/vue-js/"}]},{"title":"raspberryPi 入门","slug":"raspberryPi-note","date":"2021-01-23T21:54:28.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2021/01/23/raspberryPi-note/","link":"","permalink":"http://muzig.github.io/2021/01/23/raspberryPi-note/","excerpt":"之前在储备前端技术, 目前使用树莓派来搭建开发环境, 便于测试.","text":"之前在储备前端技术, 目前使用树莓派来搭建开发环境, 便于测试. TODO 购买建议 初次使用 初次启动 必会命令 如何搭建LAMP环境 如何搭建开发环境 友情链接 TODO 完善文档 购买建议准备: 树莓派4b 设备电源 microHDMI转HDMI 或 转VGA 读卡器 micro-SD卡(8G,16G, 32G) 任意即可 键盘 显示器 初次使用 下载iso镜像 烧录进micro-sd 将micro-sd插入树莓派(不是用读卡器插入usb接口, 而是有一个专门的插入micro-sd的位置) 直接启动, 即可进入界面 123456# mac 烧录方式# 在Mac OS下SD卡的设备名一般为rdisk*，可以用diskutil list命令查看。# 在Linux下SD卡的设备名一般为sd*，可以用lsblk命令查看。sudo dd bs=1m if=&lt;下载的镜像.img&gt; of=/dev/&lt;SD卡设备名&gt; conv=sync# 报错提醒: dd: /dev/disk2: Resource busy# 则执行 diskutil umountDisk /dev/disk2 初次启动 设置区域, 开启wifi功能 连接wifi 设置root密码 12345# 设置相关参数sudo raspi-config# 设置root密码sudo passwd root 必会命令如何搭建LAMP环境如何搭建开发环境友情链接 如何给树莓派安装操作系统 如何方便的烧录镜像","categories":[{"name":"工具","slug":"工具","permalink":"http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"raspberryPi","slug":"raspberryPi","permalink":"http://muzig.github.io/tags/raspberryPi/"}]},{"title":"Golang Escape Analysis","slug":"golang-escape-analysis","date":"2020-12-27T14:42:27.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2020/12/27/golang-escape-analysis/","link":"","permalink":"http://muzig.github.io/2020/12/27/golang-escape-analysis/","excerpt":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码.","text":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码. 关于堆栈 逃逸分析 函数变量 间接赋值 interface channel 可变参数 总结 参考链接 Go 语言较之 C 语言一个很大的优势就是自带 GC 功能，可 GC 并不是没有代价的。写 C 语言的时候，在一个函数内声明的变量，在函数退出后会自动释放掉，因为这些变量分配在栈上。如果你想要变量的数据能在函数退出后还能访问，就需要调用 malloc 方法在堆上申请内存，如果程序不再需要这块内存了，再调用 free 方法释放掉。Go 语言不需要你主动调用 malloc 来分配堆空间，编译器会自动分析，找出需要 malloc 的变量，使用堆内存。编译器的这个分析过程就叫做逃逸分析。 关于堆栈区别如下: 申请方式的不同。栈由系统自动分配，而堆是人为申请开辟; 申请大小的不同。栈获得的空间较小，而堆获得的空间较大; 申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢; 存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排; 底层不同。栈是连续的空间，而堆是不连续的空间。 详细细节链接: Language Mechanics On Stacks And Pointers Language Mechanics On Escape Analysis 12345678910func stack() int &#123; // 变量 i 会在栈上分配 i := 10 return i&#125;func heap() *int &#123; // 变量 j 会在堆上分配 j := 10 return &amp;j&#125; 123# 分析汇编指令如下:go build --gcflags &#x27;-l&#x27; test.gogo tool objdump ./test !!! 不要以为使用了堆内存就一定会导致性能低下，使用栈内存会带来性能优势。因为实际项目中，系统的性能瓶颈一般都不会出现在内存分配上。千万不要盲目优化，找到系统瓶颈，用数据驱动优化。 逃逸分析需要使用堆空间则逃逸，这没什么可争议的。但编译器有时会将不需要使用堆空间的变量，也逃逸掉。这里是容易出现性能问题的大坑。网上有很多相关文章，列举了一些导致逃逸情况，其实总结起来就一句话： 多级间接赋值容易导致逃逸。 Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type(指针)。 记住公式 Data.Field = Value，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递。 函数变量 若函数是变量, 且参数也是引用类型, 则会发生逃逸 间接赋值 良好的写法是, 在返回的时候再引用地址 1234567891011121314151617181920212223type Data struct &#123; data map[int]int slice []int ch chan int inf interface&#123;&#125; p *int&#125;func main() &#123; d1 := Data&#123;&#125; d1.data = make(map[int]int) // GOOD: does not escape d1.slice = make([]int, 4) // GOOD: does not escape d1.ch = make(chan int, 4) // GOOD: does not escape d1.inf = 3 // GOOD: does not escape d1.p = new(int) // GOOD: does not escape d2 := new(Data) // d2 是指针变量， 下面为该指针变量中的指针成员赋值 d2.data = make(map[int]int) // BAD: escape to heap d2.slice = make([]int, 4) // BAD: escape to heap d2.ch = make(chan int, 4) // BAD: escape to heap d2.inf = 3 // BAD: escape to heap d2.p = new(int) // BAD: escape to heap&#125; interface只要使用了 Interface 类型(不是 interafce{})，那么赋值给它的变量一定会逃逸。因为 interfaceVariable.Method() 先是间接的定位到它的实际值，再调用实际值的同名方法，执行时实际值作为参数传递给方法。相当于interfaceVariable.Method.this = realValue 123456789101112131415type Iface interface &#123; Dummy()&#125;type Integer intfunc (i Integer) Dummy() &#123;&#125;func main() &#123; var ( iface Iface i Integer ) iface = i iface.Dummy() // make i escape to heap // 形成 iface.Dummy.i = i&#125; channel 发送到 channel 的数据类型都将逃逸 12345678910111213func test() &#123; var ( chInteger = make(chan *int) chMap = make(chan map[int]int) chSlice = make(chan []int) chInterface = make(chan interface&#123;&#125;) a, b, c, d = 0, map[int]int&#123;&#125;, []int&#123;&#125;, 32 ) chInteger &lt;- &amp;a // 逃逸 chMap &lt;- b // 逃逸 chSlice &lt;- c // 逃逸 chInterface &lt;- d // 逃逸&#125; 可变参数可变参数如 func(arg …string) 实际与 func(arg []string) 是一样的，会增加一层访问路径。这也是 fmt.Sprintf 总是会使参数逃逸的原因。 例子非常多，这里不能一一列举，我们只需要记住分析方法就好 即，2 级或更多级的访问赋值会容易导致数据逃逸。这里加上容易二字是因为随着语言的发展，相信这些问题会被慢慢解决，但现阶段，这个可以作为我们分析逃逸现象的依据。 123456789101112type User struct &#123; roles []string&#125;func (u *User) SetRoles(roles []string) &#123; u.roles = roles&#125;func SetRoles(u User, roles []string) User &#123; u.roles = roles return u&#125; 12345678910111213141516171819202122232425type User struct &#123; A []string&#125;func (u *User) Set(a []string) &#123; u.A = a&#125;func SetUser(user User, a []string) User &#123; user.A = a return user&#125;func BenchmarkUser(b *testing.B) &#123; // BenchmarkUser-4 39182143 29.0 ns/op //u := new(User) //for i := 0; i &lt; b.N; i++ &#123; // u.Set([]string&#123;&quot;a&quot;&#125;) //&#125; // BenchmarkUser-4 1000000000 0.585 ns/op for i := 0; i &lt; b.N; i++ &#123; _ = SetUser(User&#123;&#125;, []string&#123;&quot;a&quot;&#125;) &#125;&#125; 总结 大多数情况下，性能优化都会为程序带来一定的复杂度。建议实际项目中还是怎么方便怎么写，功能完成后通过性能分析找到瓶颈所在，再对局部进行优化。 多级间接赋值会导致 Go 编译器出现不必要的逃逸，在一些情况下可能我们只需要修改一下数据结构就会使性能有大幅提升。这也是很多人不推荐在 Go 中使用指针的原因，因为它会增加一级访问路径，而 map, slice, interface{}等类型是不可避免要用到的，为了减少不必要的逃逸，只能拿指针开刀了。 参考链接 达菲格-Go 语言内存管理（三）：逃逸分析","categories":[{"name":"后端","slug":"后端","permalink":"http://muzig.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://muzig.github.io/tags/golang/"},{"name":"escape-analysis","slug":"escape-analysis","permalink":"http://muzig.github.io/tags/escape-analysis/"}]},{"title":"Golang GC","slug":"golang-GC","date":"2020-12-26T23:32:41.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2020/12/26/golang-GC/","link":"","permalink":"http://muzig.github.io/2020/12/26/golang-GC/","excerpt":"标记清除 并行标记清除 三色标记法 Hybrid Write Barrier","text":"标记清除 并行标记清除 三色标记法 Hybrid Write Barrier 标记清除 &amp; 并行标记清除 三色标记法 Hybrid Write Barrier (混合写屏障) 何时触发 GC 其他优化 展望 结论 参考链接 标记清除 &amp; 并行标记清除GC 开始之后, 启动 STW 然后从 root 开始, root 区值当前所有 goroutine 的栈和全局数据区的变量(主要是这 2 个地方), 将能被触及的 object 标记, 剩下的就是可回收的; 最后再清理放回 mcache 中, 以备后续使用. 并行标记清除, 实际上是清理过程不需要 STW, 减少了 STW 的时间. 三色标记法 正常情况下，写操作就是正常的赋值。 GC 开始，开启写屏障等准备工作。开启写屏障等准备工作需要短暂的 STW。 Stack scan 阶段，从全局空间和 goroutine 栈空间上收集变量。 Mark 阶段，执行上述的三色标记法，直到没有灰色对象。 Mark termination 阶段，开启 STW，回头重新扫描 root 区域新变量，对他们进行标记。 Sweep 阶段，关闭 STW 和 写屏障，对白色对象进行清除。 Hybrid Write Barrier (混合写屏障)Go 在 1.8 版本引入了混合写屏障，其会在赋值前，对旧数据置灰，再视情况对新值进行置灰。 何时触发 GC 容量触发 - 达到设置的阈值触发 GC, 默认为100(即内存增长100%即触发一次), 可以通过环境变量 GOGC 或者 debug.SetGCPercent() 时间触发 - 每隔 2 分钟, 触发一次 GC 手动触发 - runtime.GC() 其他优化 只会占用 25% 的 cpu 算力处理 GC 逻辑, 保证减少对用户的影响. 若下一轮 GC 触发, 会等待上一轮执行完毕 对于 tiny 对象, 直接标记黑色, 没有灰色阶段, 因为不存在引用对象 采用对象池的方式, 减少 GC 的压力, 但实际上也会存在标记的压力; 如果可以放在永久标记, 就可以减少标记压力 直接申请大内存(大于32k), 对 GC 来说是一个 largespan; 需要自行代码管理 展望 引入分代机制, 像 JVM 那样内存分为 一级/二级/永久, 不同级别, 采用不同的计算资源 结论 减少层级数 - 嵌套层级越多, 对于 GC 的压力越大; 如: chan map[string][]*string 参考链接 Golang GC核心要点和度量方法 常见GC算法及Golang GC 达菲格-Go 语言内存管理（四）","categories":[{"name":"后端","slug":"后端","permalink":"http://muzig.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://muzig.github.io/tags/golang/"},{"name":"gc","slug":"gc","permalink":"http://muzig.github.io/tags/gc/"}]},{"title":"Golang Scheduling","slug":"golang-scheduling","date":"2020-12-26T15:40:47.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2020/12/26/golang-scheduling/","link":"","permalink":"http://muzig.github.io/2020/12/26/golang-scheduling/","excerpt":"熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.","text":"熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑. GPM 模型 调度流程 用户方式阻塞/唤醒 syscall sysmon 抢占式调度 netpoll g 的创建流程 g 的暂停方式 Go 调度查看方式 总结 参考链接 GPM 模型文件位置: src/runtime/runtime2.go g(goroutine): 对应到 g 结构体, 保存 goroutin 需要的堆栈信息 p(process): 相当于 g 的驱动, 只有绑定在 local runq 下, 才能被调度 m(machine): \bOS 线程抽象, 真正的驱动力, 和某个 p 绑定, 然后 p 从 local runq 中依次取出 g 用来执行 补充: 最早 go1.1 仅仅是 GM 模式, 后续 Dmitry Vyukov 为了解决并发伸缩性问题, 引入 p 的概念 提案文档 g 的数量受限于 GOMAXPROCS, 即超线程数量, 一般 intel cpu 具有超线程技术, 双核四线程, 即数量为4 m 的个数是不定的，由Go Runtime调整，默认最大限制为10000个 调度流程 m 与 p 绑定, m 从 p 的 local runq 中取出并切换到 g 的堆栈执行 若 local runq 存在 g, 则执行(无锁) 若不存在, 从 global runq 取出 g 执行(有锁) 若依然不存在, 则从其他 p “窃取” g 执行 若没有 g 可以执行, 则 m 与 p 解绑, 进入休眠模式(idle) 用户方式阻塞/唤醒阻塞: 当 g 被 channel 卡住, m 会跳过执行下一个, 并将 g 放置在 waitq 里面 唤醒: 当 g 执行的时候, 通过 channel 向另一个 g2 投递消息, 则 g2 将直接”插队”, 放下一个执行 syscall若 g 被阻塞在一个系统调用上, 则 p 将于 m 解绑, 寻找 idle 状态的 m 再此绑定; 若没有 idle 状态的 m, 则创建一个新的 m. 系统调用结束, g 会重新寻找 idle 状态的 p, 并恢复执行, 若没有则放到 globl runq 中. 系统被调度的两个关键点: runtime/syscall包中, 系统调用分为 syscall &amp; rawsyscall, 区别在于前者会记录保存和恢复所需状态, 这样可以安全的解绑; 某些系统调用可以预先评估是会长时间阻塞, 则会发起之前, 直接 p &amp; m 解绑(handoffp) sysmon 负责检查系统调用时间, 决定是否需要 handoffp sysmonsysmon 是一个由 runtime 启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次. 流程如下: 释放闲置超过5分钟的span物理内存； 如果超过2分钟没有垃圾回收，强制执行； 将长时间未处理的netpoll结果添加到任务队列； 向长时间运行的G任务发出抢占调度； 收回因syscall长时间阻塞的P； 抢占式调度当某个 g 执行超过10ms, 则 sysmon 将发起抢占式请求, 会给 g 打上标签; 当 g 执行函数时(更确切说，在通过newstack分配函数栈时), 将被 runtime.Goched 的方式暂停, 放置在 global runq 中 netpoll除了之前提到的, local runq, runqnext, global runq, 还存在对网络 I/O 进行优化的 netpoll, 本地避免网络I/O的时候陷入系统调用, 不阻塞 M (而是阻塞 G ), 从而不会导致大量的 M 被创建 g 的创建流程 当 go func(){} 执行的时候, 会尝试从池子中复用, 没有则创建 尝试”插队”, 放置到当前 p 的 runnext 里面 否则放置到 local runq 中(无锁) 否则放置到 global runq 中(有锁) g 的暂停方式 常规方式 - 将 g 阻塞, 放到 global runq 中, 等待被获取执行 等待方式 - 将 g 阻塞, 放到 waitq 中, 等待被其他 g 唤醒 自旋方式 - gpm 都不调度, 直到被唤醒 退出方式 - 立即终止 g 任务, 确保 defer 正常执行 process 方式 - 放飞 p, 阻塞 g m, p 可以跟其他 m 绑定 Go 调度查看方式 Go 调度模型 总结从调度模型, 到 gpm 的探讨, 讲到了阻塞和唤醒的流程, 以及如何抢占, 延伸到 sysmon 服务的特点; 最后补充了 netpoll 优化和 g 的创建流程和状态介绍.回过头来, 我们再看看, 学习调度的目的其实实际需求来讲, 就是编写更加高效的并发程序, 明白了流程, 还需要实战, 后续再更新代码实战的情况. 参考链接 Go 调度模型 再谈调度 达菲格-Go 语言调度（一）: 系统调度 达菲格-Go 语言调度（二）: goroutine 调度器 达菲格-Go 语言调度（三）: 并发","categories":[{"name":"后端","slug":"后端","permalink":"http://muzig.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://muzig.github.io/tags/golang/"},{"name":"scheduling","slug":"scheduling","permalink":"http://muzig.github.io/tags/scheduling/"}]},{"title":"Shell 笔记","slug":"shell-note","date":"2020-12-19T15:22:53.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2020/12/19/shell-note/","link":"","permalink":"http://muzig.github.io/2020/12/19/shell-note/","excerpt":"在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务. 科技改变生活, 脚本释放双手.","text":"在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务. 科技改变生活, 脚本释放双手. 基础语法 变量 字符串 数组 注释 传参 运算符 算数运算符 逻辑运算符 布尔运算符 关系运算符 字符串运算符 文件测试运算符 流程控制 条件控制 循环控制 函数 重定向 /dev/null 文件 文件引用 oh-my-zsh 源码 参考链接 基础语法变量123# 赋值等号两边不能添加空格name=&#x27;hello&#x27;echo $&#123;name&#125; 123# 常量name=&#x27;hello&#x27;readonly name 123# 删除变量name=&#x27;hello&#x27;unset name 字符串 单引号 原样输出, 不支持变量引用 双引号 支持变量引用 支持转义字符 123# 获取字符串长度name=&#x27;hello&#x27;echo $&#123;#name&#125; 123# 提取字符串name=&#x27;hello world&#x27;echo $&#123;name:1:3&#125; # 输出ell 123# 查找字符串string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 数组123array_name=(value1 value2 ... valuen)# 访问v1=$&#123;array_name[0]&#125; 注释1234567# 单行注释:&lt;&lt;EOF多行注释多行注释EOF符号可以换成其他, 比如`&#x27;之类的EOF 传参 $0: 文件名 $1: 命令行执行的第一个参数 $2: 命令行执行的第二个参数 运算符算数运算符 逻辑运算符 布尔运算符 关系运算符 字符串运算符 文件测试运算符 流程控制关键字: break continue 条件控制12345678910111213# 多行if condition1then command1elif condition2 then command2else commandNfi# 单行if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 循环控制1234567891011# 多行for var in item1 item2 ... itemNdo command1 command2 ... commandNdone# 单行for var in item1 item2 ... itemN; do command1; command2… done; 1234567891011121314151617# 条件循环while conditiondo commanddone# 条件循环until conditiondo commanddone# 无限循环while :do commanddone 函数12345678910# 语法[ function ] funname [()]&#123; action; [return int;]&#125; 123456demoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 1234输出结果:-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 重定向 /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1command &gt; /dev/null 文件引用1url=&quot;http://muzig.github.io&quot; 1234567# 使用 . 号来引用src.sh 文件. ./src.sh# 或者使用以下包含文件代码source ./src.shecho &quot;Blog：$url&quot; 12输出:Blog: http://muzig.github.io oh-my-zsh 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# If ZSH is not defined, use the current script&#x27;s directory.[[ -z &quot;$ZSH&quot; ]] &amp;&amp; export ZSH=&quot;$&#123;$&#123;(%):-%x&#125;:a:h&#125;&quot;# Set ZSH_CACHE_DIR to the path where cache files should be created# or else we will use the default cache/if [[ -z &quot;$ZSH_CACHE_DIR&quot; ]]; then ZSH_CACHE_DIR=&quot;$ZSH/cache&quot;fi# Check for updates on initial load...if [ &quot;$DISABLE_AUTO_UPDATE&quot; != &quot;true&quot; ]; then source $ZSH/tools/check_for_upgrade.shfi# Initializes Oh My Zsh# add a function pathfpath=($ZSH/functions $ZSH/completions $fpath)# Load all stock functions (from $fpath files) called below.autoload -U compaudit compinit# Set ZSH_CUSTOM to the path where your custom config files# and plugins exists, or else we will use the default custom/if [[ -z &quot;$ZSH_CUSTOM&quot; ]]; then ZSH_CUSTOM=&quot;$ZSH/custom&quot;fiis_plugin() &#123; local base_dir=$1 local name=$2 builtin test -f $base_dir/plugins/$name/$name.plugin.zsh \\ || builtin test -f $base_dir/plugins/$name/_$name&#125;# Add all defined plugins to fpath. This must be done# before running compinit.for plugin ($plugins); do if is_plugin $ZSH_CUSTOM $plugin; then fpath=($ZSH_CUSTOM/plugins/$plugin $fpath) elif is_plugin $ZSH $plugin; then fpath=($ZSH/plugins/$plugin $fpath) else echo &quot;[oh-my-zsh] plugin &#x27;$plugin&#x27; not found&quot; fidone# Figure out the SHORT hostnameif [[ &quot;$OSTYPE&quot; = darwin* ]]; then # macOS&#x27;s $HOST changes with dhcp, etc. Use ComputerName if possible. SHORT_HOST=$(scutil --get ComputerName 2&gt;/dev/null) || SHORT_HOST=$&#123;HOST/.*/&#125;else SHORT_HOST=$&#123;HOST/.*/&#125;fi# Save the location of the current completion dump file.if [ -z &quot;$ZSH_COMPDUMP&quot; ]; then ZSH_COMPDUMP=&quot;$&#123;ZDOTDIR:-$&#123;HOME&#125;&#125;/.zcompdump-$&#123;SHORT_HOST&#125;-$&#123;ZSH_VERSION&#125;&quot;fi# Construct zcompdump OMZ metadatazcompdump_revision=&quot;#omz revision: $(builtin cd -q &quot;$ZSH&quot;; git rev-parse HEAD 2&gt;/dev/null)&quot;zcompdump_fpath=&quot;#omz fpath: $fpath&quot;# Delete the zcompdump file if OMZ zcompdump metadata changedif ! command grep -q -Fx &quot;$zcompdump_revision&quot; &quot;$ZSH_COMPDUMP&quot; 2&gt;/dev/null \\ || ! command grep -q -Fx &quot;$zcompdump_fpath&quot; &quot;$ZSH_COMPDUMP&quot; 2&gt;/dev/null; then command rm -f &quot;$ZSH_COMPDUMP&quot; zcompdump_refresh=1fiif [[ $ZSH_DISABLE_COMPFIX != true ]]; then source $ZSH/lib/compfix.zsh # If completion insecurities exist, warn the user handle_completion_insecurities # Load only from secure directories compinit -i -C -d &quot;$&#123;ZSH_COMPDUMP&#125;&quot;else # If the user wants it, load from all found directories compinit -u -C -d &quot;$&#123;ZSH_COMPDUMP&#125;&quot;fi# Append zcompdump metadata if missingif (( $zcompdump_refresh )); then # Use `tee` in case the $ZSH_COMPDUMP filename is invalid, to silence the error # See https://github.com/ohmyzsh/ohmyzsh/commit/dd1a7269#commitcomment-39003489 tee -a &quot;$ZSH_COMPDUMP&quot; &amp;&gt;/dev/null &lt;&lt;EOF$zcompdump_revision$zcompdump_fpathEOFfiunset zcompdump_revision zcompdump_fpath zcompdump_refresh# Load all of the config files in ~/oh-my-zsh that end in .zsh# TIP: Add files you don&#x27;t want in git to .gitignorefor config_file ($ZSH/lib/*.zsh); do custom_config_file=&quot;$&#123;ZSH_CUSTOM&#125;/lib/$&#123;config_file:t&#125;&quot; [ -f &quot;$&#123;custom_config_file&#125;&quot; ] &amp;&amp; config_file=$&#123;custom_config_file&#125; source $config_filedone# Load all of the plugins that were defined in ~/.zshrcfor plugin ($plugins); do if [ -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh elif [ -f $ZSH/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH/plugins/$plugin/$plugin.plugin.zsh fidone# Load all of your custom configurations from custom/for config_file ($ZSH_CUSTOM/*.zsh(N)); do source $config_filedoneunset config_file# Load the themeif [ ! &quot;$ZSH_THEME&quot; = &quot;&quot; ]; then if [ -f &quot;$ZSH_CUSTOM/$ZSH_THEME.zsh-theme&quot; ]; then source &quot;$ZSH_CUSTOM/$ZSH_THEME.zsh-theme&quot; elif [ -f &quot;$ZSH_CUSTOM/themes/$ZSH_THEME.zsh-theme&quot; ]; then source &quot;$ZSH_CUSTOM/themes/$ZSH_THEME.zsh-theme&quot; else source &quot;$ZSH/themes/$ZSH_THEME.zsh-theme&quot; fifi 参考链接 阮一峰的《Bash 脚本教程》 Shell 教程 | 菜鸟教程","categories":[{"name":"脚本","slug":"脚本","permalink":"http://muzig.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://muzig.github.io/tags/shell/"},{"name":"note","slug":"note","permalink":"http://muzig.github.io/tags/note/"}]},{"title":"Goland 破解教程","slug":"goland-cracking","date":"2020-12-05T12:58:28.000Z","updated":"2021-04-11T13:48:00.208Z","comments":true,"path":"2020/12/05/goland-cracking/","link":"","permalink":"http://muzig.github.io/2020/12/05/goland-cracking/","excerpt":"破解方式: 循环重置试用时间.","text":"破解方式: 循环重置试用时间. 教程 友情链接 教程步骤: 打开 goland, 选择试用, 进入IDE界面 Menu - Goland - Perference - Plugins 点击像齿轮的图标(如下图) Manager Plugin Repos 添加此链接: https://plugins.zhile.io, 等待刷新完成 搜索插件 IDE Eval reset, 插件描述有说明和使用方法 下载安装重启 IDE 友情链接 破解大佬博客","categories":[{"name":"工具","slug":"工具","permalink":"http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"crack","slug":"crack","permalink":"http://muzig.github.io/tags/crack/"},{"name":"goland","slug":"goland","permalink":"http://muzig.github.io/tags/goland/"}]}],"categories":[{"name":"Mac","slug":"Mac","permalink":"http://muzig.github.io/categories/Mac/"},{"name":"工具","slug":"工具","permalink":"http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"前端","slug":"前端","permalink":"http://muzig.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://muzig.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"脚本","slug":"脚本","permalink":"http://muzig.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"scp","slug":"scp","permalink":"http://muzig.github.io/tags/scp/"},{"name":"git","slug":"git","permalink":"http://muzig.github.io/tags/git/"},{"name":"mac","slug":"mac","permalink":"http://muzig.github.io/tags/mac/"},{"name":"tmux","slug":"tmux","permalink":"http://muzig.github.io/tags/tmux/"},{"name":"vue.js","slug":"vue-js","permalink":"http://muzig.github.io/tags/vue-js/"},{"name":"raspberryPi","slug":"raspberryPi","permalink":"http://muzig.github.io/tags/raspberryPi/"},{"name":"golang","slug":"golang","permalink":"http://muzig.github.io/tags/golang/"},{"name":"escape-analysis","slug":"escape-analysis","permalink":"http://muzig.github.io/tags/escape-analysis/"},{"name":"gc","slug":"gc","permalink":"http://muzig.github.io/tags/gc/"},{"name":"scheduling","slug":"scheduling","permalink":"http://muzig.github.io/tags/scheduling/"},{"name":"shell","slug":"shell","permalink":"http://muzig.github.io/tags/shell/"},{"name":"note","slug":"note","permalink":"http://muzig.github.io/tags/note/"},{"name":"crack","slug":"crack","permalink":"http://muzig.github.io/tags/crack/"},{"name":"goland","slug":"goland","permalink":"http://muzig.github.io/tags/goland/"}]}