<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Runtime on Muzig 的技术博客</title>
    <link>https://muzig.io/tags/runtime/</link>
    <description>Recent content in Runtime on Muzig 的技术博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 15 Aug 2025 11:24:22 +0800</lastBuildDate>
    <atom:link href="https://muzig.io/tags/runtime/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>编程语言运行流程剖析</title>
      <link>https://muzig.io/2025/08/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/</link>
      <pubDate>Fri, 15 Aug 2025 11:24:22 +0800</pubDate>
      <guid>https://muzig.io/2025/08/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/</guid>
      <description>&lt;p&gt;编程语言要在机器上运行，核心是将人类可读的代码转换为机器能理解的&lt;strong&gt;二进制指令&lt;/strong&gt;（0和1），最终由CPU执行。这个过程因语言类型（编译型、解释型等）而有所不同，但本质都是“翻译+执行”的过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;核心逻辑从人类语言到机器语言的转换&#34;&gt;核心逻辑：从“人类语言”到“机器语言”的转换&lt;/h2&gt;&#xA;&lt;p&gt;机器（尤其是CPU）只能直接理解&lt;strong&gt;机器码&lt;/strong&gt;——一串由0和1组成的指令（如&lt;code&gt;01010011&lt;/code&gt;），这些指令对应CPU的基础操作（如“读取内存数据”“加法运算”“跳转执行”）。&lt;/p&gt;&#xA;&lt;p&gt;而编程语言（无论是C、Python还是Java）是人类便于理解的“高级语言”，必须通过某种工具（编译器、解释器等）转换成机器码才能被执行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;不同类型语言的运行流程&#34;&gt;不同类型语言的运行流程&lt;/h2&gt;&#xA;&lt;p&gt;根据转换时机和方式，编程语言大致分为三类，运行流程各有特点：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-编译型语言如ccrustgo&#34;&gt;1. 编译型语言（如C、C++、Rust、Go）&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心：提前将全部代码一次性编译为机器码，之后直接运行机器码。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;源代码（.c/.cpp）&lt;/strong&gt;：程序员编写的人类可读代码，例如 &lt;code&gt;int a = 1 + 2;&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;编译（Compiler）&lt;/strong&gt;：编译器（如GCC、Clang）将源代码转换为&lt;strong&gt;机器码&lt;/strong&gt;（二进制文件）：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;步骤细分：预处理（处理&lt;code&gt;#include&lt;/code&gt;等指令）→ 编译（源代码→汇编语言）→ 汇编（汇编语言→机器码，生成目标文件&lt;code&gt;.o&lt;/code&gt;）→ 链接（将多个目标文件和系统库合并为可执行文件，如Windows的&lt;code&gt;.exe&lt;/code&gt;、Linux的&lt;code&gt;a.out&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;执行&lt;/strong&gt;：操作系统直接加载可执行文件（机器码）到内存，CPU读取并执行这些二进制指令。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：编译后可直接运行，执行速度快；但编译产物依赖硬件架构（如x86和ARM的机器码不同），跨平台需重新编译。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-解释型语言如pythonjavascriptphp&#34;&gt;2. 解释型语言（如Python、JavaScript、PHP）&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心：边翻译边执行，不生成独立的机器码文件。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;源代码（.py/.js）&lt;/strong&gt;：程序员编写的代码，例如 &lt;code&gt;a = 1 + 2&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;解释（Interpreter）&lt;/strong&gt;：解释器（如Python解释器、Node.js）逐行处理代码：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;词法分析：将代码拆分为“单词”（如变量名、运算符）。&lt;/li&gt;&#xA;&lt;li&gt;语法分析：检查语法是否正确，生成抽象语法树（AST）。&lt;/li&gt;&#xA;&lt;li&gt;执行：直接根据AST执行操作（或生成简单中间代码再执行），无需提前编译为机器码。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：无需编译步骤，跨平台性好（只要有对应解释器）；但逐行解释会导致执行速度较慢。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-半编译型虚拟机语言如javacpython部分实现&#34;&gt;3. 半编译型/虚拟机语言（如Java、C#、Python部分实现）&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心：先编译为“中间代码”，再由虚拟机（VM）解释或编译为机器码。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;以Java为例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;源代码（.java）&lt;/strong&gt;：程序员编写的代码。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;编译为字节码（Bytecode）&lt;/strong&gt;：通过&lt;code&gt;javac&lt;/code&gt;编译器将源代码转换为&lt;strong&gt;字节码&lt;/strong&gt;（&lt;code&gt;.class&lt;/code&gt;文件），这是一种与硬件无关的中间代码（如&lt;code&gt;0xBB 0x00 0x01&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟机执行&lt;/strong&gt;：Java虚拟机（JVM）加载字节码，再将其转换为当前硬件的机器码：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解释执行：JVM逐行解释字节码（类似解释型）。&lt;/li&gt;&#xA;&lt;li&gt;即时编译（JIT）：热点代码（频繁执行的部分）会被JVM动态编译为机器码缓存，后续直接执行，兼顾跨平台和效率。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：一次编译（到字节码），多处运行（只要有对应虚拟机），平衡了跨平台性和执行效率。&lt;/p&gt;&#xA;&lt;h2 id=&#34;最终执行cpu如何运行指令&#34;&gt;最终执行：CPU如何运行指令&lt;/h2&gt;&#xA;&lt;p&gt;无论通过哪种方式生成机器码，最终都要由CPU执行，过程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;机器码指令被加载到内存的“代码段”。&lt;/li&gt;&#xA;&lt;li&gt;CPU的&lt;strong&gt;程序计数器（PC）&lt;/strong&gt; 指向当前要执行的指令地址。&lt;/li&gt;&#xA;&lt;li&gt;CPU从内存读取指令，通过&lt;strong&gt;指令解码器&lt;/strong&gt;解析指令含义（如“加法”“读取内存”）。&lt;/li&gt;&#xA;&lt;li&gt;执行指令：调用CPU内部的运算单元（如ALU算术逻辑单元）、寄存器或内存完成操作。&lt;/li&gt;&#xA;&lt;li&gt;程序计数器自动指向 next 指令，重复步骤3-4，直到程序结束（如遇到&lt;code&gt;exit&lt;/code&gt;指令）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;编程语言在机器上运行的本质，是通过“编译”“解释”或“虚拟机”等中间层，将人类可读的代码逐步转换为CPU能理解的二进制指令，最终由硬件执行。不同语言的设计（编译型/解释型）本质上是在“开发效率”“执行效率”和“跨平台性”之间做权衡。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
